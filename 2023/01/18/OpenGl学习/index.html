<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/yun.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/yun_32x32.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/yun_16x16.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="OpenGL-GLFW-GLADOpenGL自身是一个巨大的状态机OpenGl的状态通常被称为上下文 GLFW解决操作系统层面的不同-创建窗口-定义上下文-处理用户输入GLAD使得代码可以用于不同的OpenGL驱动-OpenGl本身只是标准&#x2F;规范-各个厂家具体实现方法可以不同-不同操作系统处理方法也不同GLFWhttps:&#x2F;&#x2F;www.glfw.org&#x2F;download.htmlGLAD使用了一个w">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenGL学习">
<meta property="og:url" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="寻云的布洛克">
<meta property="og:description" content="OpenGL-GLFW-GLADOpenGL自身是一个巨大的状态机OpenGl的状态通常被称为上下文 GLFW解决操作系统层面的不同-创建窗口-定义上下文-处理用户输入GLAD使得代码可以用于不同的OpenGL驱动-OpenGl本身只是标准&#x2F;规范-各个厂家具体实现方法可以不同-不同操作系统处理方法也不同GLFWhttps:&#x2F;&#x2F;www.glfw.org&#x2F;download.htmlGLAD使用了一个w">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/%E6%B7%BB%E5%8A%A0%E7%9D%80%E8%89%B2%E5%99%A8.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/image-20230108145335877.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/image-20230108161225087.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/image-20230109114631595.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/image-20230110175829032.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/image-20230111122955026.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/filter_nearest.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/filter_linear.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/texture_filtering.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/mipmaps.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%9C.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/GL_LINEAR-16739268703381.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/GL_NEAREST-16739268761223.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/mix%E7%9A%84%E6%9C%80%E5%90%8E%E5%8F%82%E6%95%B0.gif">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/vectors_crossproduct.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/vectors_angle.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/image-20230118101034538.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/%E6%97%8B%E8%BD%AC.gif">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/%E5%8F%98%E6%8D%A2%E4%BD%9C%E4%B8%9A1.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/%E6%97%8B%E8%BD%AC%E5%92%8C%E7%BC%A9%E6%94%BE-16741257251821.gif">
<meta property="og:image" content="https://learnopengl-cn.gitee.io/img/01/08/coordinate_systems.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/coordinate_systems_right_handed-16741257251832.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/%E5%9D%90%E6%A0%87%E7%B3%BB%E4%BD%9C%E4%B8%9A3-167412579151824.gif">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/camera_axes.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/camera_pitch_yaw_roll.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/camera_triangle.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/camera_pitch.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/camera_yaw.png">
<meta property="og:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/camera.gif">
<meta property="article:published_time" content="2023-01-18T05:36:20.000Z">
<meta property="article:modified_time" content="2023-01-25T11:03:04.000Z">
<meta property="article:author" content="DruidYun">
<meta property="article:tag" content="图形学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/%E6%B7%BB%E5%8A%A0%E7%9D%80%E8%89%B2%E5%99%A8.png">

<link rel="canonical" href="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>OpenGL学习 | 寻云的布洛克</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">寻云的布洛克</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录生活中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">24</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/DruidYun.jpg">
      <meta itemprop="name" content="DruidYun">
      <meta itemprop="description" content="如果你想做出让人享受的东西，那就享受做它的过程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="寻云的布洛克">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          OpenGL学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-18 13:36:20" itemprop="dateCreated datePublished" datetime="2023-01-18T13:36:20+08:00">2023-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-25 19:03:04" itemprop="dateModified" datetime="2023-01-25T19:03:04+08:00">2023-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>46k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>42 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="OpenGL-GLFW-GLAD"><a href="#OpenGL-GLFW-GLAD" class="headerlink" title="OpenGL-GLFW-GLAD"></a>OpenGL-GLFW-GLAD</h2><p>OpenGL自身是一个巨大的状态机<br>OpenGl的状态通常被称为上下文</p>
<p>GLFW解决操作系统层面的不同<br>-创建窗口<br>-定义上下文<br>-处理用户输入<br>GLAD使得代码可以用于不同的OpenGL驱动<br>-OpenGl本身只是标准/规范<br>-各个厂家具体实现方法可以不同<br>-不同操作系统处理方法也不同<br>GLFW<br><a target="_blank" rel="noopener" href="https://www.glfw.org/download.html">https://www.glfw.org/download.html</a><br>GLAD使用了一个web服务器，通过输入想要为使用的OpenGL版本和相关信息转到GLAD服务器网站（<a target="_blank" rel="noopener" href="https://glad.dav1d.de/">https://glad.dav1d.de</a>）</p>
<p>glfwWindowHint(target, Hint);</p>
<p>把某一种target设置成hint</p>
<span id="more"></span>

<p>片段：包含渲染单个像素所需的所有数据。</p>
<p>显卡上有数千个小型处理器（核），可以在渲染管线中快速处理数据。核在GPU上为管线的每一步运行小程序。这些小程序成为着色器。</p>
<p>渲染管线 每一步执行完 后再执行下一步。</p>
<p>顶点着色器处理后，顶点值应该是NDC坐标；NDC坐标使用glViewport提供的数据，通过视口转换变为屏幕坐标。生成的屏幕空间左边将转换为片段，作为片段着色器的输入。</p>
<p>标准化设备坐标（Normalized Device Coordinates，NDC）</p>
<p>顶点着色器中处理过后，就应该是标准化设备坐标了，x、y和z的值在-1.0到1.0的一小段空间（立方体）。落在范围外的坐标都会被裁剪。</p>
<h2 id="VAO、VBO"><a href="#VAO、VBO" class="headerlink" title="VAO、VBO"></a>VAO、VBO</h2><p>顶点输入</p>
<p>在GPU上创建内存，储存的顶点数据</p>
<ul>
<li>通过顶点缓冲对象（Vertex Buffer Objecits，VBO）管理</li>
<li>顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER</li>
</ul>
<p>配置OpenGL如何解释这些内存</p>
<ul>
<li>通过顶点数组对象（Vertex Array Objects，VAO）管理</li>
</ul>
<p>使用缓冲区对象的优点是，可以一次将大量数据发送到显卡，不必一次发送一个数据。</p>
<p>用着色器语言GLSL（OpenGL Shading Language）编写顶点着色器，然后进行编译。</p>
<h2 id="添加着色器"><a href="#添加着色器" class="headerlink" title="添加着色器"></a>添加着色器</h2><p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/%E6%B7%BB%E5%8A%A0%E7%9D%80%E8%89%B2%E5%99%A8.png" alt="添加着色器"></p>
<h3 id="对着色器进行编译"><a href="#对着色器进行编译" class="headerlink" title="对着色器进行编译"></a>对着色器进行编译</h3><p>为了让OpenGL使用着色器，必须在运行时从源码中动态编译着色器。首先创建着色器对象。</p>
<p>各个阶段的着色器需要通过着色器程序对象链接起来。着色器程序对象是多个着色器组成的最终链接版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *vertexShaderSource = </span><br><span class="line"><span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout(location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;gl_Position = vec4(aPos.x,aPos.y,aPos.z,1.0);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *fragmentShaderSource = </span><br><span class="line"><span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;FragColor = vec4(1.0f,0.5f,0.2f,1.0f);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\n\0&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>将着色器链接到程序时，会将每个着色器的输出连接到下一个着色器的输入.如果输出和输入不匹配，会出现链接错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建和编译着色器程序</span></span><br><span class="line">	<span class="comment">//顶点着色器</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line">	<span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">glCompileShader</span>(vertexShader);</span><br><span class="line">	<span class="comment">//检查编译错误 </span></span><br><span class="line">	<span class="type">int</span> success;</span><br><span class="line">	<span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">	<span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">	<span class="keyword">if</span> (!success)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;ERROR::Shader::VERTEX::COMPILATION_FAIED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//片段着色器</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">	<span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line">	<span class="comment">//检查编译错误</span></span><br><span class="line">	<span class="built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">	<span class="keyword">if</span> (!success)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">glGetShaderInfoLog</span>(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;ERROR::Shader::FRAGMENT::COMPILATION_FAIED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//着色器程序</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> shaderProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">	<span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line">	<span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line">	<span class="built_in">glLinkProgram</span>(shaderProgram);</span><br><span class="line">	<span class="comment">//链接错误检查</span></span><br><span class="line">	<span class="built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">	<span class="keyword">if</span> (!success)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line">	<span class="built_in">glDeleteShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>

<p>创建着色器程序</p>
<h3 id="元素缓冲对象EBO"><a href="#元素缓冲对象EBO" class="headerlink" title="元素缓冲对象EBO"></a>元素缓冲对象EBO</h3><p>EBO:Element Buffer Object</p>
<p>绘制两个三角形来组成一个矩形，可以使用下面的顶点的集合</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] =</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//第一个三角形</span></span><br><span class="line">	<span class="number">0.5f</span>,<span class="number">0.5f</span>,<span class="number">0.0f</span>,<span class="comment">//右上</span></span><br><span class="line">	<span class="number">0.5f</span>,<span class="number">-0.5f</span>,<span class="number">0.0f</span>,<span class="comment">//右下</span></span><br><span class="line">	<span class="number">-0.5f</span>,<span class="number">0.5f</span>,<span class="number">0.0f</span>,<span class="comment">//左上</span></span><br><span class="line">	<span class="comment">//第二个三角形</span></span><br><span class="line">	<span class="number">0.5f</span>,<span class="number">-0.5f</span>,<span class="number">0.0f</span>,<span class="comment">//右下</span></span><br><span class="line">	<span class="number">-0.5f</span>,<span class="number">-0.5f</span>,<span class="number">0.0f</span>,<span class="comment">//左下</span></span><br><span class="line">	<span class="number">-0.5f</span>,<span class="number">0.5f</span>,<span class="number">0.0f</span><span class="comment">//左上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过下面修改顶点数进行绘制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>可以获得以下图像</p>
<img src="image-20230108145335877.png" alt="image-20230108145335877" style="zoom: 50%;" />

<p>修改光栅化模式，改为GL_LINE后</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glPolygonMode</span>(GL_FRONT_AND_BACK, GL_LINE);</span><br></pre></td></tr></table></figure>

<img src="image-20230108161225087.png" alt="image-20230108161225087" style="zoom: 67%;" />

<p>在这种情况下，有两个左上的点，两个右下的点，其中有两个点是多余的。</p>
<p>换一种方式，用索引的方式，使用四个点的坐标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">	<span class="number">0.5f</span>,<span class="number">0.5f</span>,<span class="number">0.0f</span>,<span class="comment">// 右上</span></span><br><span class="line">	<span class="number">0.5f</span>,<span class="number">-0.5f</span>,<span class="number">0.0f</span>,<span class="comment">// 右下</span></span><br><span class="line">	<span class="number">-0.5f</span>,<span class="number">-0.5f</span>,<span class="number">0.0f</span>,<span class="comment">// 左下</span></span><br><span class="line">	<span class="number">-0.5f</span>,<span class="number">0.5f</span>,<span class="number">0.0f</span><span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">	<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="comment">//第一个三角形</span></span><br><span class="line">	<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="comment">//第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>选择使用索引渲染的函数，这样就可以绘出和上图一样的图像</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, indices); <span class="comment">//选择索引的方式</span></span><br></pre></td></tr></table></figure>

<p>PS:采用了EBO时，则需要用glDrawElements函数来代替glDrawArrays函数，来指明我们从索引缓冲渲染。</p>
<p>参照<a target="_blank" rel="noopener" href="https://www.cnblogs.com/keguniang/p/9866065.html">glDrawArrays 和 glDrawElements</a></p>
<p>这样写还不是整个的流程，还需要配置EBO</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> EBO;</span><br><span class="line">	<span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);<span class="comment">//创建缓冲区对象名字</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<span class="comment">//绑定EBO缓冲</span></span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);<span class="comment">//设置缓冲区数据</span></span><br></pre></td></tr></table></figure>

<p>修改参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span><span class="comment">/*indices*/</span>);</span><br></pre></td></tr></table></figure>

<p>然后使用绑定，之后注销</p>
<h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><p>调整窗口的时候，也应该同时调整视口。在窗口上注册一个回调函数，每次调用窗口大小时都调用该函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">frameBuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册回调函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册回调函数</span></span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, frameBuffer_size_callback);</span><br></pre></td></tr></table></figure>

<p>PS：OpenGL中使用的坐标介于-1和1之间和屏幕空间坐标不同。例如：如果屏幕右下角为（800，600），（-0.5，0.5）将映射到屏幕空间的（200，450）</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol>
<li>通过添加更多的顶点数据，使用glDrawArrays绘制两个挨在一起的三角形</li>
<li>创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO</li>
<li>创建两个着色器，其中一个使用片段做着色器输出黄色</li>
</ol>
<h2 id="着色器Shader"><a href="#着色器Shader" class="headerlink" title="着色器Shader"></a>着色器Shader</h2><p>着色器是基于GPU的小程序，这些小程序针对渲染管线中的每个特定步骤运行。从本质上说，着色器只不过是将输入转换为输出的程序。着色器也是非常孤立的程序，他们之间唯一的交流是通过输入和输出。</p>
<p>GLSL：OpenGL SHading Language</p>
<p>PS:Shader Language目前主要有3种语言：</p>
<ol>
<li>基于 OpenGL 的 <strong>OpenGL Shading Language</strong>，简称 <strong>GLSL</strong>;</li>
<li>基于 DirectX 的 <strong>High Level Shading Language</strong>,简称 <strong>HLSL</strong>;</li>
<li>还有 NVIDIA 公司的 <strong>C for Graphic</strong>，简称 <strong>Cg</strong> 语言。</li>
</ol>
<p>这是GLSL程序的典型结构</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/image-20230109114631595.png" alt="image-20230109114631595"></p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>GLSL中包含C等其它语言大部分的默认基础数据类型</p>
<ul>
<li>int、float、double、uint和bool</li>
</ul>
<p>GLSL也有两种容器类型</p>
<ul>
<li>向量(Vector)<ul>
<li>vecn: the default vector of n floats</li>
<li>bvecn: a vector of n booleans</li>
<li>ivecn: a vector of n integers</li>
<li>uvecn: a vector of n unsigned integers</li>
<li>dvecn: a vector of n double components </li>
</ul>
</li>
<li>矩阵(Matrix)</li>
</ul>
<blockquote>
<p>向量的分量可以通过xyzw分别访问。GLSL还允许对颜色使用rgba，或对纹理坐标使用stpq。</p>
</blockquote>
<p>向量允许一些有趣而灵活的分量选择方式，叫做重组(Swizzling):</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> vect = <span class="type">vec2</span>(<span class="number">0.5</span>,<span class="number">0.7</span>);</span><br><span class="line"><span class="type">vec4</span> result = <span class="type">vec4</span>(vect,<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line"><span class="type">vec4</span> otherResult = vect(result.xyz,<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p>顶点着色器接受的是一种特殊形式的输入，否则就会效率低下</p>
<p>从顶点数据中直接接受输出。为了顶点数据该如何管理，使用location这一元数据（metadata）指定输入变量，这样才可以在CPU端配置顶点属性。例如：<code>layout (location = 0)</code>。layout这个的标识，使得能把它链接到顶点数据。</p>
<p>可以忽略<code>layout(location = 0)</code>标识符，通过在OpenGL代码中使用<code>glGenAttribLocation</code>查询属性位置值(Location)，通过<code>glBindAttribLocation</code>绑定属性位置值(Location)。但是推荐在着色器中设置它们，这样会更容易理解和节省工作量。</p>
<p>输入输出：</p>
<ul>
<li>在发生方着色器中声明一个输出</li>
<li>在接受方着色器中声明一个类似的输入</li>
<li>当类型和名字都一致，OpenGL将把变量连接到一起（在链接程序对象时完成）</li>
</ul>
<h3 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform:"></a>Uniform:</h3><p> 另一种从CPU的应用，向GPU中的着色器发送数据的方式</p>
<ul>
<li><p>uniform是全局的(Global)，可以被任意着色器程序在任意阶段访问</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/image-20230110175829032.png" alt="image-20230110175829032"></p>
</li>
</ul>
<p>如果声明了一个uniform却没用过，编译器会默认移除这个变量，导致最后编译出的版本并不会包含它，这可能导致一些非常麻烦的错误，切记！</p>
<p>不去给像素传递一个单一的颜色，而是让它随着时间改变颜色</p>
<p>设置着色器，使用uniform</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *vertexShaderSource = </span><br><span class="line">	<span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">	<span class="string">&quot;layout(location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">	<span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;gl_Position = vec4(aPos,1.0);\n&quot;</span></span><br><span class="line">	<span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *fragmentShaderSource = </span><br><span class="line">	<span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">	<span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;uniform vec4 ourColor;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">	<span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;FragColor = ourColor;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;&#125;\n\0&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>最后通过sin和cos实现颜色渐变</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="comment">//设置uniform值</span></span><br><span class="line"><span class="type">float</span> timeValue = <span class="built_in">glfwGetTime</span>();</span><br><span class="line"><span class="type">float</span> greenValue = <span class="built_in">sin</span>(timeValue) / <span class="number">2.0f</span> + <span class="number">0.5F</span>;</span><br><span class="line"><span class="type">float</span> redValue = <span class="built_in">cos</span>(timeValue) / <span class="number">2.0f</span> + <span class="number">0.5F</span>;</span><br><span class="line"><span class="type">float</span> blueValue = <span class="built_in">cos</span>(timeValue+<span class="number">45</span>) / <span class="number">2.0f</span> + <span class="number">0.5F</span>;</span><br><span class="line"><span class="type">int</span> vertexColorLocation = <span class="built_in">glGetUniformLocation</span>(shaderProgram, <span class="string">&quot;ourColor&quot;</span>);</span><br><span class="line"><span class="built_in">glUniform4f</span>(vertexColorLocation, redValue, greenValue, blueValue, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>

<p>给顶点不同的颜色：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] =  <span class="comment">// 位置 // 颜色</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">-0.5f</span>,<span class="number">-0.5f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="comment">//右下</span></span><br><span class="line">	<span class="number">0.5f</span>,<span class="number">-0.5f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="comment">//左下</span></span><br><span class="line">	<span class="number">0.0f</span>,<span class="number">0.5</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span><span class="comment">//上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *vertexShaderSource = </span><br><span class="line">	<span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">	<span class="string">&quot;layout(location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;layout(location = 1) in vec3 aColor;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;out vec3 ourColor;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">	<span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;gl_Position = vec4(aPos,1.0);\n&quot;</span></span><br><span class="line">	<span class="string">&quot;ourColor = aColor;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *fragmentShaderSource = </span><br><span class="line">	<span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">	<span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;uniform vec4 ourColor;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">	<span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;FragColor = ourColor;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;&#125;\n\0&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">//告知Shader如何解析缓冲里的属性值</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="comment">//开启VAI管理的第一个属性值</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//告知Shader如何解析缓冲里的属性值</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span>*<span class="number">4</span>));</span><br><span class="line"><span class="comment">//开启VAI管理的第一个属性值</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/image-20230111122955026.png" alt="image-20230111122955026"></p>
<h2 id="编写自己的着色器类"><a href="#编写自己的着色器类" class="headerlink" title="编写自己的着色器类"></a>编写自己的着色器类</h2><p>把着色器类全部放在在头文件里，主要是为了学习用途，当然也方便移植。添加必要的include，并定义类结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span>; <span class="comment">// 包含glad来获取所有的必须OpenGL头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 程序ID</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器读取并构建着色器</span></span><br><span class="line">    <span class="built_in">Shader</span>(<span class="type">const</span> GLchar* vertexPath, <span class="type">const</span> GLchar* fragmentPath);</span><br><span class="line">    <span class="comment">// 使用/激活程序</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// uniform工具函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setBool</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">bool</span> value)</span> <span class="type">const</span></span>;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInt</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">int</span> value)</span> <span class="type">const</span></span>;   </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFloat</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">float</span> value)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>下一步，我们需要编译和链接着色器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 2. 编译着色器</span><br><span class="line">unsigned int vertex, fragment;</span><br><span class="line">// vertex shader 顶点</span><br><span class="line">vertex = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">glShaderSource(vertex, 1, &amp;vShaderCode, NULL);</span><br><span class="line">glCompileShader(vertex);</span><br><span class="line">checkCompileErrors(vertex, &quot;VERTEX&quot;);</span><br><span class="line">// fragment Shader 片元</span><br><span class="line">fragment = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragment, 1, &amp;fShaderCode, NULL);</span><br><span class="line">glCompileShader(fragment);</span><br><span class="line">checkCompileErrors(fragment, &quot;FRAGMENT&quot;);</span><br><span class="line">// shader Program </span><br><span class="line">ID = glCreateProgram();</span><br><span class="line">glAttachShader(ID, vertex); //附加vertex对象给ID</span><br><span class="line">glAttachShader(ID, fragment);</span><br><span class="line">glLinkProgram(ID);</span><br><span class="line">checkCompileErrors(ID, &quot;PROGRAM&quot;);</span><br><span class="line">// delete the shaders as they&#x27;re linked into our program now and no longer necessary</span><br><span class="line">// 因为它们已经链接程序，不再需要，然后就删除这些着色器</span><br><span class="line">glDeleteShader(vertex);</span><br><span class="line">glDeleteShader(fragment);</span><br></pre></td></tr></table></figure>

<p>设置use函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glUseProgram</span>(ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一些有用Uniform函数</span></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setBool</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">bool</span> value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ID, name.<span class="built_in">c_str</span>()), (<span class="type">int</span>)value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setInt</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ID, name.<span class="built_in">c_str</span>()), value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setFloat</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">float</span> value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glUniform1f</span>(<span class="built_in">glGetUniformLocation</span>(ID, name.<span class="built_in">c_str</span>()), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后创建着色器对象，再使用</p>
<h3 id="着色器练习"><a href="#着色器练习" class="headerlink" title="着色器练习"></a>着色器练习</h3><ul>
<li><p>修改顶点着色器让三角形上下颠倒：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="comment">//修改顶点着色器，让aPos.y变成负值</span></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos.x,- aPos.y,aPos.z, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用uniform定义一个水平偏移量，在顶点着色器中使用这个偏移量把三角形移动到屏幕右侧：</p>
<ul>
<li>在C++代码设置</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> offset = <span class="number">0.5f</span>;</span><br><span class="line">ourShader.<span class="built_in">setFloat</span>(<span class="string">&quot;xOffset&quot;</span>, offset);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>​    在顶点着色器</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> xOffset;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos.x + xOffset, aPos.y, aPos.z, <span class="number">1.0</span>); <span class="comment">// add the xOffset to the x position of the vertex position</span></span><br><span class="line">    ourColor = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用<code>out</code>关键字把顶点位置输出到片段着色器，并将片段的颜色设置为与顶点位置相等（来看看连顶点位置值都在三角形中被插值的结果）。做完这些后，尝试回答下面的问题：为什么在三角形的左下角是黑的?：</p>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out vec3 ourColor;</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourPosition;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>); </span><br><span class="line">    <span class="comment">// ourColor = aColor;</span></span><br><span class="line">    ourPosition = aPos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片元</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out vec3 ourColor;</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourPosition;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>); </span><br><span class="line">    <span class="comment">// ourColor = aColor;</span></span><br><span class="line">    ourPosition = aPos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回答：因为左下角的顶点的坐标为<code>(-0.5f,-0.5f,0.0f)</code>,在作为颜色显示的时候负值被固定为0，而(0,0,0,1)就是黑色，而这一直发生那个顶点插值到其他顶点的过程，所以导致了左下角为黑边。</p>
<h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>纹理是一个2D图片(其实也有1D和3D的纹理)，它可以用来添加物体的细节。            </p>
<blockquote>
<p>纹理也可以用来存储大量数据。</p>
</blockquote>
<h3 id="纹理坐标"><a href="#纹理坐标" class="headerlink" title="纹理坐标"></a>纹理坐标</h3><p>纹理坐标(Texture Coordinate)：每一个顶点会关联一个纹理坐标，用来标明该从纹理图像的哪个部分采样。之后再图形的其它片段进行片段插值(Fragment Interpolation)。</p>
<p>纹理坐标也是在x和y轴，分别范围也为[0,1]；</p>
<p>采样(Sampling)：使用纹理坐标获取纹理颜色。</p>
<h3 id="纹理环绕方式-Texture-Wrapping"><a href="#纹理环绕方式-Texture-Wrapping" class="headerlink" title="纹理环绕方式(Texture Wrapping)"></a>纹理环绕方式(Texture Wrapping)</h3><p>纹理坐标的范围通常是从(0,0)到(1,1)，当外面设置的纹理坐标超出了范围，OpenGL的行为是重复这个纹理图像，也提供了一下可以选择的方式</p>
<table>
<thead>
<tr>
<th>环绕方式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GL_REPEAT</td>
<td>对纹理的默认行为。重复纹理图像。</td>
</tr>
<tr>
<td>GL_MIRRORED_REPEAT</td>
<td>和GL_REPEAT一样，但每次重复图片是镜像放置的。</td>
</tr>
<tr>
<td>GL_CLAMP_TO_EDGE</td>
<td>纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td>
</tr>
<tr>
<td>GL_CLAMP_TO_BORDER</td>
<td>超出的坐标为用户指定的边缘颜色。</td>
</tr>
</tbody></table>
<p>通过使用glTexParameter*函数，可以使用上面提及的每一个选项来对单独的坐标系(s、t、r(如果使用3D纹理的话))，它们和x、y、z等价</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT); </span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</span><br></pre></td></tr></table></figure>

<p>第一个参数指定纹理目标，这里使用2D纹理，所以这里使用GL_TEXTURE_2D。第二个参数要求我们提供我们需要设置的纹理坐标系，这里我们选择S轴和T轴，最后一个参数指定纹理环绕方式。</p>
<p>如果选择了GL_CLAMP_TO_BORDERGL_CLAMP_TO_BORDER的选项，我们还需要选择外围的颜色。这里需要使用glTexParameter函数带fv后置的形式来设置当超出边界后外围的颜色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> borderColor[] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="built_in">glTexParameterfv</span>(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor); </span><br></pre></td></tr></table></figure>

<h3 id="纹理过滤-Texture-Filtering"><a href="#纹理过滤-Texture-Filtering" class="headerlink" title="纹理过滤(Texture Filtering)"></a>纹理过滤(Texture Filtering)</h3><p>纹理坐标不依赖分辨率，它可以是任意浮点值，所以OpenGl需要知道怎么样将纹理像素(Texture Pixel,也叫Texel)映射到纹理坐标，当有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。所以OpenGL也有对于纹理过滤(Texture Filtering)的选项，纹理过滤有很多选项，这里只讨论最重要的两种：GL_NEARET和GL_LINEAR.</p>
<blockquote>
<p>Texture Pixel也叫Texel，你可以想象你打开一张<code>.jpg</code>格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。</p>
</blockquote>
<p>GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/filter_nearest.png" alt="filter_nearest"></p>
<p>GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色：</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/filter_linear.png" alt="filter_linear"></p>
<p>这两种纹理过滤方式的视觉效果，用一个很大的物体上应用一张低分辨率纹理，（纹理被放大了，每个纹理像素都能看到）：</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/texture_filtering.png" alt="texture_filtering"></p>
<h3 id="多级渐远纹理"><a href="#多级渐远纹理" class="headerlink" title="多级渐远纹理"></a>多级渐远纹理</h3><p>OpenGL使用一种叫做多级渐远纹理(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的：</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/mipmaps.png" alt="mipmaps"></p>
<p>OpenGL有一个glGenerateMipmaps函数，可以在创建完一个纹理后调用 OpenGL就会自动接着干这些事。</p>
<p>在渲染过程中切换多级渐远纹理级别时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。像普通的纹理过滤，不同的纹理级别切换也可以使用NEAREST和LINEAR过滤。</p>
<table>
<thead>
<tr>
<th>过滤方式</th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>GL_NEAREST_MIPMAP_NEAREST</td>
<td>使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td>
</tr>
<tr>
<td>GL_LINEAR_MIPMAP_NEAREST</td>
<td>使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td>
</tr>
<tr>
<td>GL_NEAREST_MIPMAP_LINEAR</td>
<td>在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td>
</tr>
<tr>
<td>GL_LINEAR_MIPMAP_LINEAR</td>
<td>在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td>
</tr>
</tbody></table>
<p>就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure>

<h3 id="加载与创建纹理"><a href="#加载与创建纹理" class="headerlink" title="加载与创建纹理"></a>加载与创建纹理</h3><h3 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h3><p>你可能会奇怪为什么<code>sampler2D</code>变量是个uniform，我们却不用glUniform给它赋值。使用glUniform1i，我们可以给纹理采样器分配一个位置值，这样的话我们能够在一个片段着色器中设置多个纹理。一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，它是默认的激活纹理单元</p>
<p>纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元。就像glBindTexture一样，我们可以使用glActiveTexture激活纹理单元，传入我们需要使用的纹理单元：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0); <span class="comment">// 在绑定纹理之前先激活纹理单元</span></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure>

<p>激活纹理单元之后，接下来的glBindTexture函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元GL_TEXTURE0默认总是被激活，所以我们在前面的例子里当我们使用<code>glBindTexture</code>的时候，无需激活任何纹理单元。</p>
<blockquote>
<p>OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。</p>
</blockquote>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><ul>
<li>修改片段着色器，<strong>仅</strong>让笑脸图案朝另一个方向看，<a target="_blank" rel="noopener" href="https://learnopengl.com/code_viewer.php?code=getting-started/textures-exercise1">参考解答</a></li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture1;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(texture1, TexCoord), <span class="built_in">texture</span>(texture2, <span class="type">vec2</span>(<span class="number">1.0</span>-TexCoord.x,TexCoord.y)), <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>尝试用不同的纹理环绕方式，设定一个从<code>0.0f</code>到<code>2.0f</code>范围内的（而不是原来的<code>0.0f</code>到<code>1.0f</code>）纹理坐标。试试看能不能在箱子的角落放置4个笑脸：<a target="_blank" rel="noopener" href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.3.textures_exercise2/textures_exercise2.cpp">参考解答</a>，<a target="_blank" rel="noopener" href="https://learnopengl-cn.gitee.io/img/01/06/textures_exercise2.png">结果</a>。记得一定要试试其它的环绕方式。</p>
<ul>
<li>修改纹理坐标    </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">	<span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">		 <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">2.0f</span>, <span class="number">2.0f</span>,   <span class="comment">// 右上</span></span><br><span class="line">		 <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">2.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">		<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">		<span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">2.0f</span>    <span class="comment">// 左上</span></span><br><span class="line">&#125;;		</span><br></pre></td></tr></table></figure>

<ul>
<li>修改第一个纹理的环绕方式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>修改第二个纹理的环绕方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br></pre></td></tr></table></figure></li>
<li><p>结果</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%9C.png" alt="结果"></p>
</li>
</ul>
</li>
<li><p>尝试在矩形上只显示纹理图像的中间一部分，修改纹理坐标，达到能看见单个的像素的效果。尝试使用GL_NEAREST的纹理过滤方式让像素显示得更清晰：<a target="_blank" rel="noopener" href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.4.textures_exercise3/textures_exercise3.cpp">参考解答</a></p>
<ul>
<li>修改纹理坐标</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">	<span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">		 <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.55f</span>, <span class="number">0.55f</span>,   <span class="comment">// 右上</span></span><br><span class="line">		 <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.55f</span>, <span class="number">0.45f</span>,   <span class="comment">// 右下</span></span><br><span class="line">		<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.45f</span>, <span class="number">0.45f</span>,   <span class="comment">// 左下</span></span><br><span class="line">		<span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.45f</span>, <span class="number">0.55f</span>    <span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>修改过滤方式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br></pre></td></tr></table></figure>



<ul>
<li>结果(第一种为GL_LINEAR，第二个为GL_NEAREST)</li>
</ul>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/GL_LINEAR-16739268703381.png"></p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/GL_NEAREST-16739268761223.png"></p>
</li>
<li><p>使用一个uniform变量作为mix函数的第三个参数来改变两个纹理可见度，使用上和下键来改变箱子或笑脸的可见度：<a target="_blank" rel="noopener" href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.5.textures_exercise4/textures_exercise4.cpp">参考解答</a>。</p>
<ul>
<li>修改片段着色器</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture1;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture2;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> parm;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(texture1, TexCoord), <span class="built_in">texture</span>(texture2, <span class="type">vec2</span>(<span class="number">1.0</span>-TexCoord.x,TexCoord.y)), parm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>设置uniform和按键</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> parm = <span class="number">0.2f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*......*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if (parm &gt;= 1.0f)</span></span><br><span class="line"><span class="comment">//	parm = 1.0f;</span></span><br><span class="line"><span class="comment">//if (parm &lt;= 0.0f)</span></span><br><span class="line"><span class="comment">//	parm = 0.0f;</span></span><br><span class="line">ourShader.<span class="built_in">setFloat</span>(<span class="string">&quot;parm&quot;</span>, parm);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_UP) == GLFW_PRESS)</span><br><span class="line">parm += <span class="number">0.01</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_DOWN) == GLFW_PRESS)</span><br><span class="line">parm -= <span class="number">0.01</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/mix%E7%9A%84%E6%9C%80%E5%90%8E%E5%8F%82%E6%95%B0.gif" alt="mix的最后参数"></p>
<h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><h3 id="向量的点乘和叉乘"><a href="#向量的点乘和叉乘" class="headerlink" title="向量的点乘和叉乘"></a>向量的点乘和叉乘</h3><ol>
<li><p>点乘(Dot Product)</p>
<p>​    两个向量的点乘等于它们的数乘结果乘以两个向量之间夹角的余弦值。可能听起来有点费解，我们来看一下公式：<br>$$<br>\bar{v}⋅\bar{k}=||\bar{v}||⋅||\bar{k}||⋅cosθ<br>$$<br>​    它们之间的夹角记作$$θ$$。为什么这很有用？想象如果$\bar{v}$和$\bar{k}$都是单位向量，它们的长度会等于1。这样公式会有效简化成：<br>$$<br>\bar{v}⋅\bar{k}=1⋅1⋅cosθ=cosθ<br>$$</p>
</li>
</ol>
<p>​    你也可以通过点乘的结果计算两个非单位向量的夹角，点乘的结果除以两个向量的长度之积，得到的结果就是夹角的余弦值，即cosθ。<br>$$<br>\cos \theta = \frac{\bar{v} \cdot \bar{k}}{||\bar{v}|| \cdot ||\bar{k}||}<br>$$<br>​    点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的。两个单位向量的（你可以验证它们的长度都为1）点乘会像是这样：<br>$$<br>\begin{pmatrix} \color{red}{0.6} \\ -\color{green}{0.8} \\ \color{blue}0 \end{pmatrix} \cdot \begin{pmatrix} \color{red}0 \\ \color{green}1 \\ \color{blue}0 \end{pmatrix} = (\color{red}{0.6} * \color{red}0) + (-\color{green}{0.8} * \color{green}1) + (\color{blue}0 * \color{blue}0) = -0.8<br>$$<br>​    2.叉乘(Cross Product)</p>
<p>​    叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量。接下来的教程中这会非常有用。下面的图片展示了3D空间中叉乘的样子：</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/vectors_crossproduct.png" alt="vectors_crossproduct"></p>
<p>两个正交向量A和B叉积：<br>$$<br>\begin{pmatrix} \color{red}{A_{x}} \\ \color{green}{A_{y}} \\ \color{blue}{A_{z}} \end{pmatrix} \times \begin{pmatrix} \color{red}{B_{x}} \\ \color{green}{B_{y}} \\ \color{blue}{B_{z}}  \end{pmatrix} = \begin{pmatrix} \color{green}{A_{y}} \cdot \color{blue}{B_{z}} - \color{blue}{A_{z}} \cdot \color{green}{B_{y}} \\ \color{blue}{A_{z}} \cdot \color{red}{B_{x}} - \color{red}{A_{x}} \cdot \color{blue}{B_{z}} \\ \color{red}{A_{x}} \cdot \color{green}{B_{y}} - \color{green}{A_{y}} \cdot \color{red}{B_{x}} \end{pmatrix}<br>$$</p>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>向量，它其实就是一个<strong>N×1</strong>矩阵，N表示向量分量的个数（也叫N维(N-dimensional)向量）</p>
<h4 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h4><p>在OpenGL中，由于某些原因我们通常使用<strong>4×4</strong>的变换矩阵，而其中最重要的原因就是大部分的向量都是4分量的。我们能想到的最简单的变换矩阵就是单位矩阵(Identity Matrix)。单位矩阵是一个除了对角线以外都是0的<strong>N×N</strong>矩阵。在下式中可以看到，这种变换矩阵使一个向量完全不变：<br>$$<br>\begin{bmatrix} \color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\ \color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}0 \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{bmatrix} 1 \\ 2 \\ 3 \\ 4 \end{bmatrix} = \begin{bmatrix} \color{red}1 \cdot 1 \\ \color{green}1 \cdot 2 \\ \color{blue}1 \cdot 3 \\ \color{purple}1 \cdot 4 \end{bmatrix} = \begin{bmatrix} 1 \\ 2 \\ 3 \\ 4 \end{bmatrix}<br>$$<br>向量看起来完全没变。从乘法法则来看就很容易理解来：第一个结果元素是矩阵的第一行的每个元素乘以向量的每个对应元素。因为每行的元素除了第一个都是0，可得：$$\color{red}1\cdot1 + \color{red}0\cdot2 + \color{red}0\cdot3 + \color{red}0\cdot4 = 1$$，向量的其他3个元素同理。</p>
<blockquote>
<p>单位矩阵通常是生成其他变换矩阵的起点。</p>
</blockquote>
<h4 id="缩放矩阵"><a href="#缩放矩阵" class="headerlink" title="缩放矩阵"></a>缩放矩阵</h4><p>对一个向量进行缩放(Scaling)就是对向量的长度进行缩放，而保持它的方向不变。由于我们进行的是2维或3维操作，我们可以分别定义一个有2或3个缩放变量的向量，每个变量缩放一个轴(x、y或z)。</p>
<blockquote>
<p>记住，OpenGL通常是在3D空间进行操作的，对于2D的情况我们可以把z轴缩放1倍，这样z轴的值就不变了。我们刚刚的缩放操作是不均匀(Non-uniform)缩放，因为每个轴的缩放因子(Scaling Factor)都不一样。如果每个轴的缩放因子都一样那么就叫均匀缩放(Uniform Scale)。</p>
</blockquote>
<p>$$<br>\begin{bmatrix} \color{red}{S_1} &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\ \color{green}0 &amp; \color{green}{S_2} &amp; \color{green}0 &amp; \color{green}0 \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}{S_3} &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} \color{red}{S_1} \cdot x \\ \color{green}{S_2} \cdot y \\ \color{blue}{S_3} \cdot z \\ 1 \end{pmatrix}<br>$$</p>
<p>记住，OpenGL通常是在3D空间进行操作的，对于2D的情况我们可以把z轴缩放1倍，这样z轴的值就不变了。我们刚刚的缩放操作是不均匀(Non-uniform)缩放，因为每个轴的缩放因子(Scaling Factor)都不一样。如果每个轴的缩放因子都一样那么就叫均匀缩放(Uniform Scale)。</p>
<h4 id="位移矩阵"><a href="#位移矩阵" class="headerlink" title="位移矩阵"></a>位移矩阵</h4><p>位移(Translation)是在原始向量的基础上加上另一个向量从而获得一个在不同位置的新向量的过程，从而在位移向量基础上<strong>移动</strong>了原始向量。我们已经讨论了向量加法，所以这应该不会太陌生。</p>
<p>和缩放矩阵一样，在4×4矩阵上有几个特别的位置用来执行特定的操作，对于位移来说它们是第四列最上面的3个值。如果我们把位移向量表示为$$(\color{red}{T_x},\color{green}{T_y},\color{blue}{T_z})$$，我们就能把位移矩阵定义为：<br>$$<br>\begin{bmatrix}  \color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}{T_x} \\ \color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}{T_y} \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}{T_z} \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} x + \color{red}{T_x} \\ y + \color{green}{T_y} \\ z + \color{blue}{T_z} \\ 1 \end{pmatrix}<br>$$<br>这样是能工作的，因为所有的位移值都要乘以向量的<strong>w</strong>行，所以位移值会加到向量的原始值上（想想矩阵乘法法则）。而如果你用3x3矩阵我们的位移值就没地方放也没地方乘了，所以是不行的。</p>
<blockquote>
<p><strong>齐次坐标(Homogeneous Coordinates)</strong></p>
<p>向量的w分量也叫齐次坐标。想要从齐次向量得到3D向量，我们可以把x、y和z坐标分别除以w坐标。我们通常不会注意这个问题，因为w分量通常是1.0。使用齐次坐标有几点好处：它允许我们在3D向量上进行位移（如果没有w分量我们是不能位移向量的），而且下一章我们会用w值创建3D视觉效果。</p>
<p>如果一个向量的齐次坐标是0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移</p>
</blockquote>
<p>有了位移矩阵我们就可以在3个方向(x、y、z)上移动物体，它是我们的变换工具箱中非常有用的一个变换矩阵。</p>
<h4 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h4><p>2D或3D空间中的旋转用角(Angle)来表示。角可以是角度制或弧度制的，周角是360角度或2 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pi">PI</a>弧度。</p>
<blockquote>
<p>大多数旋转函数需要用弧度制的角，但幸运的是角度制的角也可以很容易地转化为弧度制的：</p>
<ul>
<li>弧度转角度：<code>角度 = 弧度 * (180.0f / PI)</code></li>
<li>角度转弧度：<code>弧度 = 角度 * (PI / 180.0f)</code></li>
</ul>
<p><code>PI</code>约等于3.14159265359。</p>
</blockquote>
<p>转半圈会旋转360/2 = 180度，向右旋转1/5圈表示向右旋转360/5 = 72度。下图中展示的2D向量$\bar{v}$是由$\bar{k}$向右旋转72度所得的：</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/vectors_angle.png" alt="vectors_angle"></p>
<p>在3D空间中旋转需要定义一个角<strong>和</strong>一个旋转轴(Rotation Axis)。物体会沿着给定的旋转轴旋转特定角度。如果你想要更形象化的感受，可以试试向下看着一个特定的旋转轴，同时将你的头部旋转一定角度。当2D向量在3D空间中旋转时，我们把旋转轴设为z轴（尝试想象这种情况）。</p>
<p>使用三角学，给定一个角度，可以把一个向量变换为一个经过旋转的新向量。这通常是使用一系列正弦和余弦函数（一般简称sin和cos）各种巧妙的组合得到的。当然，讨论如何生成变换矩阵超出了这个教程的范围。</p>
<p>旋转矩阵在3D空间中每个单位轴都有不同定义，旋转角度用$θ$表示：</p>
<p>沿x轴旋转：<br>$$<br>\begin{bmatrix} \color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\ \color{green}0 &amp; \color{green}{\cos \theta} &amp; - \color{green}{\sin \theta} &amp; \color{green}0 \\ \color{blue}0 &amp; \color{blue}{\sin \theta} &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} x \\ \color{green}{\cos \theta} \cdot y - \color{green}{\sin \theta} \cdot z \\ \color{blue}{\sin \theta} \cdot y + \color{blue}{\cos \theta} \cdot z \\ 1 \end{pmatrix}<br>$$</p>
<p>沿y轴旋转：<br>$$<br>\begin{bmatrix} \color{red}{\cos \theta} &amp; \color{red}0 &amp; \color{red}{\sin \theta} &amp; \color{red}0 \\ \color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}0 \\ - \color{blue}{\sin \theta} &amp; \color{blue}0 &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} \color{red}{\cos \theta} \cdot x + \color{red}{\sin \theta} \cdot z \\ y \\ - \color{blue}{\sin \theta} \cdot x + \color{blue}{\cos \theta} \cdot z \\ 1 \end{pmatrix}<br>$$</p>
<p>沿z轴旋转：<br>$$<br>\begin{bmatrix} \color{red}{\cos \theta} &amp; - \color{red}{\sin \theta} &amp; \color{red}0 &amp; \color{red}0 \\ \color{green}{\sin \theta} &amp; \color{green}{\cos \theta} &amp; \color{green}0 &amp; \color{green}0 \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} \color{red}{\cos \theta} \cdot x - \color{red}{\sin \theta} \cdot y  \\ \color{green}{\sin \theta} \cdot x + \color{green}{\cos \theta} \cdot y \\ z \\ 1 \end{pmatrix}<br>$$<br>利用旋转矩阵我们可以把任意位置向量沿一个单位旋转轴进行旋转。也可以将多个矩阵复合，比如先沿着x轴旋转再沿着y轴旋转。但是这会很快导致一个问题——万向节死锁（Gimbal Lock，可以看看<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=zc8b2Jo7mno">这个视频</a><a target="_blank" rel="noopener" href="http://v.youku.com/v_show/id_XNzkyOTIyMTI=.html">（优酷）</a>来了解）。在这里我们不会讨论它的细节，但是对于3D空间中的旋转，一个更好的模型是沿着任意的一个轴，比如单位向量$(0.662, 0.2, 0.7222)$旋转，而不是对一系列旋转矩阵进行复合。这样的一个（超级麻烦的）矩阵是存在的，见下面这个公式，其中$(\color{red}{R_x}, \color{green}{R_y}, \color{blue}{R_z})$代表任意旋转轴：<br>$$<br>\begin{bmatrix} \cos \theta + \color{red}{R_x}^2(1 - \cos \theta) &amp; \color{red}{R_x}\color{green}{R_y}(1 - \cos \theta) - \color{blue}{R_z} \sin \theta &amp; \color{red}{R_x}\color{blue}{R_z}(1 - \cos \theta) + \color{green}{R_y} \sin \theta &amp; 0 \\ \color{green}{R_y}\color{red}{R_x} (1 - \cos \theta) + \color{blue}{R_z} \sin \theta &amp; \cos \theta + \color{green}{R_y}^2(1 - \cos \theta) &amp; \color{green}{R_y}\color{blue}{R_z}(1 - \cos \theta) - \color{red}{R_x} \sin \theta &amp; 0 \\ \color{blue}{R_z}\color{red}{R_x}(1 - \cos \theta) - \color{green}{R_y} \sin \theta &amp; \color{blue}{R_z}\color{green}{R_y}(1 - \cos \theta) + \color{red}{R_x} \sin \theta &amp; \cos \theta + \color{blue}{R_z}^2(1 - \cos \theta) &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}<br>$$<br>在数学上讨论如何生成这样的矩阵仍然超出了本节内容。但是记住，即使这样一个矩阵也不能完全解决万向节死锁问题（尽管会极大地避免）。避免万向节死锁的真正解决方案是使用四元数(Quaternion)，它不仅更安全，而且计算会更有效率。四元数可能会在后面的教程中讨论。</p>
<h4 id="矩阵的组合"><a href="#矩阵的组合" class="headerlink" title="矩阵的组合"></a>矩阵的组合</h4><p>使用矩阵进行变换的真正力量在于，根据矩阵之间的乘法，我们可以把多个变换组合到一个矩阵中。让我们看看我们是否能生成一个变换矩阵，让它组合多个变换。假设我们有一个顶点(x, y, z)，我们希望将其缩放2倍，然后位移(1, 2, 3)个单位。我们需要一个位移和缩放矩阵来完成这些变换。结果的变换矩阵看起来像这样：<br>$$<br>Trans . Scale = \begin{bmatrix} \color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}1 \\ \color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}2 \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}3 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} . \begin{bmatrix} \color{red}2 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\ \color{green}0 &amp; \color{green}2 &amp; \color{green}0 &amp; \color{green}0 \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}2 &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} = \begin{bmatrix} \color{red}2 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}1 \\ \color{green}0 &amp; \color{green}2 &amp; \color{green}0 &amp; \color{green}2 \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}2 &amp; \color{blue}3 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix}<br>$$<br>注意，当矩阵相乘时我们先写位移再写缩放变换的。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的，所以你应该从右向左读这个乘法。建议您在组合矩阵时，先进行缩放操作，然后是旋转，最后才是位移，否则它们会（消极地）互相影响。比如，如果你先位移再缩放，位移的向量也会同样被缩放（译注：比如向某方向移动2米，2米也许会被缩放成1米）！</p>
<p>用最终的变换矩阵左乘我们的向量会得到以下结果：<br>$$<br>\begin{bmatrix} \color{red}2 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}1 \\ \color{green}0 &amp; \color{green}2 &amp; \color{green}0 &amp; \color{green}2 \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}2 &amp; \color{blue}3 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} . \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} = \begin{bmatrix} \color{red}2x + \color{red}1 \\ \color{green}2y + \color{green}2  \\ \color{blue}2z + \color{blue}3 \\ 1 \end{bmatrix}<br>$$<br>向量先缩放2倍，然后位移了(1, 2, 3)个单位。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>GLM是Open<strong>GL</strong> <strong>M</strong>athematics的缩写，它是一个<strong>只有头文件的</strong>库，也就是说我们只需包含对应的头文件就行了，不用链接和编译。GLM可以在它们的<a target="_blank" rel="noopener" href="https://glm.g-truc.net/0.9.8/index.html">网站</a>上下载。把头文件的根目录复制到你的<strong>includes</strong>文件夹，然后你就可以使用这个库了。</p>
<blockquote>
<p>GLM库从0.9.9版本起，默认会将矩阵类型初始化为一个零矩阵（所有元素均为0），而不是单位矩阵（对角元素为1，其它元素为0）。如果你使用的是0.9.9或0.9.9以上的版本，你需要将所有的矩阵初始化改为 <code>glm::mat4 mat = glm::mat4(1.0f)</code>。如果你想与本教程的代码保持一致，请使用低于0.9.9版本的GLM，或者改用上述代码初始化所有的矩阵。</p>
</blockquote>
<p>我们需要的GLM的大多数功能都可以从下面这3个头文件中找到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>我们来看看是否可以利用我们刚学的变换知识把一个向量(1, 0, 0)位移(1, 1, 0)个单位（注意，我们把它定义为一个<code>glm::vec4</code>类型的值，齐次坐标设定为1.0）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec4 <span class="title">vec</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line">glm::mat4 trans = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">trans = glm::<span class="built_in">translate</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">vec = trans * vec;</span><br><span class="line">std::cout &lt;&lt; vec.x &lt;&lt; vec.y &lt;&lt; vec.z &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>我们先用GLM内建的向量类定义一个叫做<code>vec</code>的向量。接下来定义一个<code>mat4</code>类型的<code>trans</code>，默认是一个4×4单位矩阵。下一步是创建一个变换矩阵，我们是把单位矩阵和一个位移向量传递给<code>glm::translate</code>函数来完成这个工作的（然后用给定的矩阵乘以位移矩阵就能获得最后需要的矩阵）。 之后我们把向量乘以位移矩阵并且输出最后的结果。如果你仍记得位移矩阵是如何工作的话，得到的向量应该是(1 + 1, 0 + 1, 0 + 0)，也就是(2, 1, 0)。这个代码片段将会输出<code>210</code>，所以这个位移矩阵是正确的。</p>
<p>我们来做些更有意思的事情，让我们来旋转和缩放之前教程中的那个箱子。首先我们把箱子逆时针旋转90度。然后缩放0.5倍，使它变成原来的一半大。我们先来创建变换矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 trans = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">trans = glm::<span class="built_in">rotate</span>(trans, glm::<span class="built_in">radians</span>(<span class="number">90.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line">trans = glm::<span class="built_in">scale</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));  </span><br></pre></td></tr></table></figure>

<p>首先，我们把箱子在每个轴都缩放到0.5倍，然后沿z轴旋转90度。GLM希望它的角度是弧度制的(Radian)，所以我们使用<code>glm::radians</code>将角度转化为弧度。注意有纹理的那面矩形是在XY平面上的，所以我们需要把它绕着z轴旋转。因为我们把这个矩阵传递给了GLM的每个函数，GLM会自动将矩阵相乘，返回的结果是一个包括了多个变换的变换矩阵。</p>
<p>下一个大问题是：如何把矩阵传递给着色器？我们在前面简单提到过GLSL里也有一个<code>mat4</code>类型。所以我们将修改顶点着色器让其接收一个<code>mat4</code>的uniform变量，然后再用矩阵uniform乘以位置向量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec2 aTexCoord;<span class="comment">//注意这里只使用了两个location属性，而之前的纹理使用了三个，出了问题，需要在cpp文件中修改渲染顶点步长，和属性个数</span></span><br><span class="line"></span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">uniform mat4 transform;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = transform * <span class="built_in">vec4</span>(aPos, <span class="number">1.0f</span>);</span><br><span class="line">    TexCoord = <span class="built_in">vec2</span>(aTexCoord.x, <span class="number">1.0</span> - aTexCoord.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GLSL也有<code>mat2</code>和<code>mat3</code>类型从而允许了像向量一样的混合运算。前面提到的所有数学运算（像是标量-矩阵相乘，矩阵-向量相乘和矩阵-矩阵相乘）在矩阵类型里都可以使用。当出现特殊的矩阵运算的时候我们会特别说明。</p>
<p>在把位置向量传给gl_Position之前，我们先添加一个uniform，并且将其与变换矩阵相乘。我们的箱子现在应该是原来的二分之一大小并（向左）旋转了90度。当然，我们仍需要把变换矩阵传递给着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> transformLoc = <span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;transform&quot;</span>);</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(transformLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(trans));</span><br></pre></td></tr></table></figure>

<p>我们首先查询uniform变量的地址，然后用有<code>Matrix4fv</code>后缀的glUniform函数把矩阵数据发送给着色器。第一个参数你现在应该很熟悉了，它是uniform的位置值。第二个参数告诉OpenGL我们将要发送多少个矩阵，这里是1。第三个参数询问我们我们是否希望对我们的矩阵进行置换(Transpose)，也就是说交换我们矩阵的行和列。OpenGL开发者通常使用一种内部矩阵布局，叫做列主序(Column-major Ordering)布局。GLM的默认布局就是列主序，所以并不需要置换矩阵，我们填<code>GL_FALSE</code>。最后一个参数是真正的矩阵数据，但是GLM并不是把它们的矩阵储存为OpenGL所希望接受的那种，因此我们要先用GLM的自带的函数value_ptr来变换这些数据。</p>
<p>我们创建了一个变换矩阵，在顶点着色器中声明了一个uniform，并把矩阵发送给了着色器，着色器会变换我们的顶点坐标。最后的结果应该看起来像这样：</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/image-20230118101034538.png" alt="image-20230118101034538"></p>
<p>完美！我们的箱子向左侧旋转，并是原来的一半大小，所以变换成功了。我们现在做些更有意思的，看看我们是否可以让箱子随着时间旋转，我们还会重新把箱子放在窗口的右下角。要让箱子随着时间推移旋转，我们必须在游戏循环中更新变换矩阵，因为它在每一次渲染迭代中都要更新。我们使用GLFW的时间函数来获取不同时间的角度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 trans = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">trans = glm::<span class="built_in">translate</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>));</span><br><span class="line">trans = glm::<span class="built_in">rotate</span>(trans, (<span class="type">float</span>)<span class="built_in">glfwGetTime</span>(), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/%E6%97%8B%E8%BD%AC.gif" alt="旋转"></p>
<h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><ul>
<li>使用应用在箱子上的最后一个变换，尝试将其改变为先旋转，后位移。看看发生了什么，试着想想为什么会发生这样的事情：<a target="_blank" rel="noopener" href="https://learnopengl.com/code_viewer.php?code=getting-started/transformations-exercise1">参考解答</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 trans = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">trans = glm::<span class="built_in">rotate</span>(trans, (<span class="type">float</span>)glm::<span class="built_in">radians</span>(<span class="number">36.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">trans = glm::<span class="built_in">translate</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"><span class="comment">//回答：旋转会修改坐标轴，会让位移的方向发生变化</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/%E5%8F%98%E6%8D%A2%E4%BD%9C%E4%B8%9A1.png" alt="变换作业1"></p>
<ul>
<li>尝试再次调用glDrawElements画出第二个箱子，<strong>只</strong>使用变换将其摆放在不同的位置。让这个箱子被摆放在窗口的左上角，并且会不断的缩放（而不是旋转）。（<code>sin</code>函数在这里会很有用，不过注意使用<code>sin</code>函数时应用负值会导致物体被翻转）：<a target="_blank" rel="noopener" href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/5.2.transformations_exercise2/transformations_exercise2.cpp">参考解答</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ourShader.<span class="built_in">use</span>();</span><br><span class="line"><span class="comment">//第一个箱子</span></span><br><span class="line">glm::mat4 trans = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">trans = glm::<span class="built_in">rotate</span>(trans, (<span class="type">float</span>)<span class="built_in">glfwGetTime</span>(), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> transformLoc = <span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;transform&quot;</span>);</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(transformLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(trans));</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//第二个箱子</span></span><br><span class="line">trans = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>); </span><br><span class="line">trans = glm::<span class="built_in">translate</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>));</span><br><span class="line"><span class="type">float</span> scaleAmount = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">sin</span>(<span class="built_in">glfwGetTime</span>()))/<span class="number">2</span> + <span class="number">0.5f</span>;</span><br><span class="line">trans = glm::<span class="built_in">scale</span>(trans, glm::<span class="built_in">vec3</span>(scaleAmount, scaleAmount, scaleAmount));</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(transformLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(trans));</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/%E6%97%8B%E8%BD%AC%E5%92%8C%E7%BC%A9%E6%94%BE-16741257251821.gif" alt="旋转和缩放"></p>
<h2 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2><p>OpenGL希望在每次顶点着色器运行后，我们可见的所有顶点都为标准化设备坐标(Normalized Device Coordinate, NDC)。也就是说，每个顶点的<strong>x</strong>，<strong>y</strong>，<strong>z</strong>坐标都应该在**-1.0<strong>到</strong>1.0**之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。然后将这些标准化设备坐标传入光栅器(Rasterizer)，将它们变换为屏幕上的二维坐标或像素。</p>
<p>将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统(Coordinate System)。将物体的坐标变换到几个<strong>过渡</strong>坐标系(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统：</p>
<ul>
<li>局部空间(Local Space，或者称为物体空间(Object Space))</li>
<li>世界空间(World Space)</li>
<li>观察空间(View Space，或者称为视觉空间(Eye Space))</li>
<li>裁剪空间(Clip Space)</li>
<li>屏幕空间(Screen Space)</li>
</ul>
<p>这就是一个顶点在最终被转化为片段之前需要经历的所有不同状态。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵。我们的顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕坐标(Screen Coordinate)的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：</p>
<p><img src="https://learnopengl-cn.gitee.io/img/01/08/coordinate_systems.png" alt="coordinate_systems"></p>
<ol>
<li>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</li>
<li>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</li>
<li>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li>
<li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。</li>
<li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li>
</ol>
<h3 id="局部空间"><a href="#局部空间" class="headerlink" title="局部空间"></a>局部空间</h3><p>局部空间是指物体所在的坐标空间，即对象最开始所在的地方。想象你在一个建模软件（比如说Blender）中创建了一个立方体。你创建的立方体的原点有可能位于(0, 0, 0)，即便它有可能最后在程序中处于完全不同的位置。甚至有可能你创建的所有模型都以(0, 0, 0)为初始位置（译注：然而它们会最终出现在世界的不同位置）。所以，你的模型的所有顶点都是在<strong>局部</strong>空间中：它们相对于你的物体来说都是局部的。</p>
<p>我们一直使用的那个箱子的顶点是被设定在-0.5到0.5的坐标范围中，(0, 0)是它的原点。这些都是局部坐标。</p>
<h3 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h3><p>如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点(0, 0, 0)上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵(Model Matrix)实现的。</p>
<p>模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它缩小（它在局部空间中太大了），并将其位移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。你也可以把上一节将箱子到处摆放在场景中用的那个矩阵大致看作一个模型矩阵；我们将箱子的局部坐标变换到场景/世界中的不同位置。</p>
<h3 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h3><p>观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵(View Matrix)里，它被用来将世界坐标变换到观察空间。在下一节中我们将深入讨论如何创建一个这样的观察矩阵来模拟一个摄像机。</p>
<h3 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h3><p>在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间(Clip Space)名字的由来。</p>
<p>因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以我们会指定自己的坐标集(Coordinate Set)并将它变换回标准化设备坐标系，就像OpenGL期望的那样。</p>
<p>为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(1250, 500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于1.0的标准化设备坐标，所以被裁剪掉了。</p>
<blockquote>
<p>如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。组合空间</p>
</blockquote>
<p>由投影矩阵创建的<strong>观察箱</strong>(Viewing Box)被称为平截头体(Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到2D观察空间坐标）被称之为投影(Projection)，因为使用投影矩阵能将3D坐标投影(Project)到很容易映射到2D的标准化设备坐标系中。</p>
<p>一旦所有顶点被变换到裁剪空间，最终的操作——透视除法(Perspective Division)将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是将4D裁剪空间坐标变换为3D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行。</p>
<p>在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用glViewport中的设定），并被变换成片段。</p>
<p>将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个正射投影矩阵(Orthographic Projection Matrix)或一个透视投影矩阵(Perspective Projection Matrix)。</p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标：<br>$$<br>V_{clip} = M_{projection} \cdot M_{view} \cdot M_{model} \cdot V_{local}<br>$$<br>注意矩阵运算的顺序是相反的（记住我们需要从右往左阅读矩阵的乘法）。最后的顶点应该被赋值到顶点着色器中的gl_Position，OpenGL将会自动进行透视除法和裁剪。</p>
<blockquote>
<p>顶点着色器的输出要求所有的顶点都在裁剪空间内，这正是我们刚才使用变换矩阵所做的。OpenGL然后对<strong>裁剪坐标</strong>执行<strong>透视除法</strong>从而将它们变换到<strong>标准化设备坐标</strong>。OpenGL会使用glViewPort内部的参数来将标准化设备坐标映射到<strong>屏幕坐标</strong>，每个坐标都关联了一个屏幕上的点（在我们的例子中是一个800x600的屏幕）。这个过程称为视口变换。</p>
</blockquote>
<h3 id="进入3D"><a href="#进入3D" class="headerlink" title="进入3D"></a>进入3D</h3><p>在开始进行3D绘图时，我们首先创建一个模型矩阵。这个模型矩阵包含了位移、缩放与旋转操作，它们会被应用到所有物体的顶点上，以<strong>变换</strong>它们到全局的世界空间。让我们变换一下我们的平面，将其绕着x轴旋转，使它看起来像放在地上一样。这个模型矩阵看起来是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 model;</span><br><span class="line">model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(<span class="number">-55.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure>

<p>通过将顶点坐标乘以这个模型矩阵，我们将该顶点坐标变换到世界坐标。我们的平面看起来就是在地板上，代表全局世界里的平面。</p>
<p>接下来我们需要创建一个观察矩阵。我们想要在场景里面稍微往后移动，以使得物体变成可见的（当在世界空间时，我们位于原点(0,0,0)）。要想在场景里面移动，先仔细想一想下面这个句子：</p>
<ul>
<li>将摄像机向后移动，和将整个场景向前移动是一样的。</li>
</ul>
<p>这正是观察矩阵所做的，我们以相反于摄像机移动的方向移动整个场景。因为我们想要往后移动，并且OpenGL是一个右手坐标系(Right-handed System)，所以我们需要沿着z轴的正方向移动。我们会通过将场景沿着z轴负方向平移来实现。它会给我们一种我们在往后移动的感觉。</p>
<blockquote>
<p><strong>右手坐标系(Right-handed System)</strong></p>
<p>按照惯例，OpenGL是一个右手坐标系。简单来说，就是正x轴在你的右手边，正y轴朝上，而正z轴是朝向后方的。想象你的屏幕处于三个轴的中心，则正z轴穿过你的屏幕朝向你。坐标系画起来如下：</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/coordinate_systems_right_handed-16741257251832.png" alt="coordinate_systems_right_handed"></p>
<p>为了理解为什么被称为右手坐标系，按如下的步骤做：</p>
<ul>
<li>沿着正y轴方向伸出你的右臂，手指着上方。</li>
<li>大拇指指向右方。</li>
<li>食指指向上方。</li>
<li>中指向下弯曲90度。</li>
</ul>
<p>如果你的动作正确，那么你的大拇指指向正x轴方向，食指指向正y轴方向，中指指向正z轴方向。如果你用左臂来做这些动作，你会发现z轴的方向是相反的。这个叫做左手坐标系，它被DirectX广泛地使用。注意在标准化设备坐标系中OpenGL实际上使用的是左手坐标系（投影矩阵交换了左右手）。</p>
</blockquote>
<p>在下一个教程中我们将会详细讨论如何在场景中移动。就目前来说，观察矩阵是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view;</span><br><span class="line"><span class="comment">// 注意，我们将矩阵向我们要进行移动场景的反方向移动。</span></span><br><span class="line">view = glm::<span class="built_in">translate</span>(view, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-3.0f</span>));</span><br></pre></td></tr></table></figure>

<p>最后我们需要做的是定义一个投影矩阵。我们希望在场景中使用透视投影，所以像这样声明一个投影矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 projection;</span><br><span class="line">projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), screenWidth / screenHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>

<p>既然我们已经创建了变换矩阵，我们应该将它们传入着色器。首先，让我们在顶点着色器中声明一个uniform变换矩阵然后将它乘以顶点坐标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">...</span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意乘法要从右向左读</span></span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还应该将矩阵传入着色器（这通常在每次的渲染迭代中进行，因为变换矩阵会经常变动）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> modelLoc = <span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;model&quot;</span>));</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(modelLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(model));</span><br><span class="line">... <span class="comment">// 观察矩阵和投影矩阵与之类似</span></span><br></pre></td></tr></table></figure>

<p>我们的顶点坐标已经使用模型、观察和投影矩阵进行变换了，最终的物体应该会：</p>
<ul>
<li>稍微向后倾斜至地板方向。</li>
<li>离我们有一些距离。</li>
<li>有透视效果（顶点越远，变得越小）。</li>
</ul>
<h3 id="Z缓冲"><a href="#Z缓冲" class="headerlink" title="Z缓冲"></a>Z缓冲</h3><p>OpenGL存储它的所有深度信息于一个Z缓冲(Z-buffer)中，也被称为深度缓冲(Depth Buffer)。GLFW会自动为你生成这样一个缓冲（就像它也有一个颜色缓冲来存储输出图像的颜色）。深度值存储在每个片段里面（作为片段的<strong>z</strong>值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试(Depth Testing)，它是由OpenGL自动完成的。</p>
<p>然而，如果我们想要确定OpenGL真的执行了深度测试，首先我们要告诉OpenGL我们想要启用深度测试；它默认是关闭的。我们可以通过glEnable函数来开启深度测试。glEnable和glDisable函数允许我们启用或禁用某个OpenGL功能。这个功能会一直保持启用/禁用状态，直到另一个调用来禁用/启用它。现在我们想启用深度测试，需要开启GL_DEPTH_TEST：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure>

<p>因为我们使用了深度测试，我们也想要在每次渲染迭代之前清除深度缓冲（否则前一帧的深度信息仍然保存在缓冲中）。就像清除颜色缓冲一样，我们可以通过在glClear函数中指定DEPTH_BUFFER_BIT位来清除深度缓冲：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure>

<h3 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h3><ul>
<li><p>对GLM的<code>projection</code>函数中的<code>FoV</code>和<code>aspect-ratio</code>参数进行实验。看能否搞懂它们是如何影响透视平截头体的。</p>
</li>
<li><p>将观察矩阵在各个方向上进行位移，来看看场景是如何改变的。注意把观察矩阵当成摄像机对象。</p>
</li>
<li><p>使用模型矩阵只让是3倍数的箱子旋转（以及第1个箱子），而让剩下的箱子保持静止。<a target="_blank" rel="noopener" href="https://learnopengl.com/code_viewer.php?code=getting-started/coordinate_systems-exercise3">参考解答</a>。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    model = glm::<span class="built_in">translate</span>(model, cubePositions[i]);</span><br><span class="line">    <span class="type">float</span> angle = <span class="number">20.0f</span> * i;</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">        angle = <span class="built_in">glfwGetTime</span>()*<span class="number">25.0f</span>;</span><br><span class="line">    model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">    ourShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>,  model);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/%E5%9D%90%E6%A0%87%E7%B3%BB%E4%BD%9C%E4%B8%9A3-167412579151824.gif" alt="坐标系作业3"></p>
<h2 id="摄像机"><a href="#摄像机" class="headerlink" title="摄像机"></a>摄像机</h2><p>OpenGL本身没有<strong>摄像机</strong>(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种<strong>我们</strong>在移动的感觉，而不是场景在移动。</p>
<h3 id="摄像机-观察空间"><a href="#摄像机-观察空间" class="headerlink" title="摄像机/观察空间"></a>摄像机/观察空间</h3><p>当我们讨论摄像机/观察空间(Camera/View Space)的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。要定义一个摄像机，我们需要它在世界空间中的位置、观察的方向、一个指向它右测的向量以及一个指向它上方的向量。细心的读者可能已经注意到我们实际上创建了一个三个单位轴相互垂直的、以摄像机的位置为原点的坐标系。</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/camera_axes.png" alt="camera_axes"></p>
<h4 id="1-摄像机位置"><a href="#1-摄像机位置" class="headerlink" title="1. 摄像机位置"></a>1. 摄像机位置</h4><p>获取摄像机位置很简单。摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量。我们把摄像机位置设置为上一节中的那个相同的位置：</p>
<blockquote>
<p>不要忘记正z轴是从屏幕指向你的，如果我们希望摄像机向后移动，我们就沿着z轴的正方向移动。</p>
</blockquote>
<h4 id="2-摄像机方向"><a href="#2-摄像机方向" class="headerlink" title="2. 摄像机方向"></a>2. 摄像机方向</h4><p>下一个需要的向量是摄像机的方向，这里指的是摄像机指向哪个方向。现在我们让摄像机指向场景原点：(0, 0, 0)。还记得如果将两个矢量相减，我们就能得到这两个矢量的差吗？用场景原点向量减去摄像机位置向量的结果就是摄像机的指向向量。由于我们知道摄像机指向z轴负方向，但我们希望方向向量(Direction Vector)指向摄像机的z轴正方向。如果我们交换相减的顺序，我们就会获得一个指向摄像机正z轴方向的向量：</p>
<blockquote>
<p><strong>方向</strong>向量(Direction Vector)并不是最好的名字，因为它实际上指向从它到目标向量的相反方向（译注：注意看前面的那个图，蓝色的方向向量大概指向z轴的正方向，与摄像机实际指向的方向是正好相反的）。</p>
</blockquote>
<h4 id="3-右轴"><a href="#3-右轴" class="headerlink" title="3. 右轴"></a>3. 右轴</h4><p>我们需要的另一个向量是一个<strong>右向量</strong>(Right Vector)，它代表摄像机空间的x轴的正方向。为获取右向量我们需要先使用一个小技巧：先定义一个<strong>上向量</strong>(Up Vector)。接下来把上向量和第二步得到的方向向量进行叉乘。两个向量叉乘的结果会同时垂直于两向量，因此我们会得到指向x轴正方向的那个向量（如果我们交换两个向量叉乘的顺序就会得到相反的指向x轴负方向的向量）：</p>
<h4 id="4-上轴"><a href="#4-上轴" class="headerlink" title="4. 上轴"></a>4. 上轴</h4><p>现在我们已经有了x轴向量和z轴向量，获取一个指向摄像机的正y轴向量就相对简单了：我们把右向量和方向向量进行叉乘：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//摄像机位置</span></span><br><span class="line">glm::vec3 cameraPos = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line"><span class="comment">//摄像机方向</span></span><br><span class="line">glm::vec3 cameraTarget = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>); <span class="comment">//朝向原点</span></span><br><span class="line">glm::vec3 cameraDirection = glm::<span class="built_in">normalize</span>(cameraPos - cameraTarget);</span><br><span class="line"><span class="comment">//摄像机右轴R</span></span><br><span class="line">glm::vec3 up = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>); </span><br><span class="line">glm::vec3 cameraRight = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(up, cameraDirection));</span><br><span class="line"><span class="comment">//摄像机上轴</span></span><br><span class="line">glm::vec3 cameraUp = glm::<span class="built_in">cross</span>(cameraDirection, cameraRight);</span><br></pre></td></tr></table></figure>

<h3 id="Look-At"><a href="#Look-At" class="headerlink" title="Look At"></a>Look At</h3><p>使用矩阵的好处之一是如果你使用3个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这3个轴外加一个平移向量来创建一个矩阵，并且你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。这正是<strong>LookAt</strong>矩阵所做的，现在我们有了3个相互垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建我们自己的LookAt矩阵了：<br>$$<br>LookAt = \begin{bmatrix} \color{red}{R_x} &amp; \color{red}{R_y} &amp; \color{red}{R_z} &amp; 0 \\ \color{green}{U_x} &amp; \color{green}{U_y} &amp; \color{green}{U_z} &amp; 0 \\ \color{blue}{D_x} &amp; \color{blue}{D_y} &amp; \color{blue}{D_z} &amp; 0 \\ 0 &amp; 0 &amp; 0  &amp; 1 \end{bmatrix} * \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; -\color{purple}{P_x} \\ 0 &amp; 1 &amp; 0 &amp; -\color{purple}{P_y} \\ 0 &amp; 0 &amp; 1 &amp; -\color{purple}{P_z} \\ 0 &amp; 0 &amp; 0  &amp; 1 \end{bmatrix}<br>$$<br>其中$\color{red}R$$是右向量，$$\color{green}U$$是是上向量，$$\color{blue}D$$是是方向向量，$$\color{purple}P$是是摄像机位置向量。注意，位置向量是相反的，因为我们最终希望把世界平移到与我们自身移动的相反方向。把这个LookAt矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。LookAt矩阵就像它的名字表达的那样：它会创建一个看着(Look at)给定目标的观察矩阵。</p>
<p>幸运的是，GLM已经提供了这些支持。我们要做的只是定义一个摄像机位置，一个目标位置和一个表示世界空间中的上向量的向量（我们计算右向量使用的那个上向量）。接着GLM就会创建一个LookAt矩阵，我们可以把它当作我们的观察矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">view = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>), </span><br><span class="line">           glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), </span><br><span class="line">           glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure>

<h3 id="自由移动"><a href="#自由移动" class="headerlink" title="自由移动"></a>自由移动</h3><p>设置几个和摄像机有关的变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos   = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="number">3.0f</span>);</span><br><span class="line">glm::vec3 cameraFront = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glm::vec3 cameraUp    = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>,  <span class="number">0.0f</span>);</span><br></pre></td></tr></table></figure>

<p>这个时候LookAt函数变为了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view = glm::<span class="built_in">lookAt</span>(cameraPos, cameraPos + cameraFront, cameraUp);</span><br></pre></td></tr></table></figure>

<p>设置相机的位置为Pos，方向为摄像机的位置加上之前的方向向量(其实刚好相反)，这样可以保证无论是在各种时候都能保持和目标方向的不变。之前已经有了按键按下的函数，现在在函数中增加几个案件命令。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">float</span> cameraSpeed = <span class="number">0.05f</span>; <span class="comment">// adjust accordingly</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_W) == GLFW_PRESS)</span><br><span class="line">        cameraPos += cameraSpeed * cameraFront;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_S) == GLFW_PRESS)</span><br><span class="line">        cameraPos -= cameraSpeed * cameraFront;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_A) == GLFW_PRESS)</span><br><span class="line">        cameraPos -= glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_D) == GLFW_PRESS)</span><br><span class="line">        cameraPos += glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们按下<strong>WASD</strong>键的任意一个，摄像机的位置都会相应更新。如果我们希望向前或向后移动，我们就把位置向量加上或减去方向向量。如果我们希望向左右移动，我们使用叉乘来创建一个<strong>右向量</strong>(Right Vector)，并沿着它相应移动就可以了。这样就创建了使用摄像机时熟悉的横移(Strafe)效果。</p>
<blockquote>
<p>注意，我们对<strong>右向量</strong>进行了标准化。如果我们没对这个向量进行标准化，最后的叉乘结果会根据cameraFront变量返回大小不同的向量。如果我们不对向量进行标准化，我们就得根据摄像机的朝向不同加速或减速移动了，但如果进行了标准化移动就是匀速的。</p>
</blockquote>
<h4 id="移动速度"><a href="#移动速度" class="headerlink" title="移动速度"></a>移动速度</h4><p>之前可以控制移动的方向，现在来调整移动的速度(cameraSpeed)。</p>
<p>目前我们的移动速度是个常量。理论上没什么问题，但是实际情况下根据处理器的能力不同，有些人可能会比其他人每秒绘制更多帧，也就是以更高的频率调用processInput函数。结果就是，根据配置的不同，有些人可能移动很快，而有些人会移动很慢。当你发布你的程序的时候，你必须确保它在所有硬件上移动速度都一样。</p>
<p>图形程序和游戏通常会跟踪一个时间差(Deltatime)变量，它储存了渲染上一帧所用的时间。我们把所有速度都去乘以deltaTime值。结果就是，如果我们的deltaTime很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。使用这种方法时，无论你的电脑快还是慢，摄像机的速度都会相应平衡，这样每个用户的体验就都一样了。</p>
<p>我们跟踪两个<strong>全局变量</strong>来计算出deltaTime值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> deltaTime = <span class="number">0.0f</span>; <span class="comment">// 当前帧与上一帧的时间差 </span></span><br><span class="line"><span class="type">float</span> lastFrame = <span class="number">0.0f</span>; <span class="comment">// 上一帧的时间</span></span><br></pre></td></tr></table></figure>

<p>在每一帧我们计算出对应的Deltatime备用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> currentFrame = <span class="built_in">glfwGetTime</span>();</span><br><span class="line">deltaTime = currentFrame - lastFrame;</span><br><span class="line">lastFrame = currentFrame;</span><br></pre></td></tr></table></figure>

<p>现在我们有了deltaTime，在计算速度的时候可以将其考虑进去了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">float</span> cameraSpeed = <span class="number">2.5f</span> * deltaTime;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="视角移动"><a href="#视角移动" class="headerlink" title="视角移动"></a>视角移动</h4><p>只用键盘移动没什么意思。特别是我们还不能转向，移动很受限制。是时候加入鼠标了！</p>
<p>为了能够改变视角，我们需要根据鼠标的输入改变cameraFront向量。然而，根据鼠标移动改变方向向量有点复杂，需要一些三角学知识。如果你对三角学知之甚少，别担心，你可以跳过这一部分，直接复制粘贴我们的代码；当你想了解更多的时候再回来看。</p>
<h5 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h5><p>欧拉角(Euler Angle)是可以表示3D空间中任何旋转的3个值，由莱昂哈德·欧拉(Leonhard Euler)在18世纪提出。一共有3种欧拉角：俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll)，下面的图片展示了它们的含义：</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/camera_pitch_yaw_roll.png" alt="camera_pitch_yaw_roll"></p>
<p>俯仰角是描述我们如何往上或往下看的角，可以在第一张图中看到。第二张图展示了偏航角，偏航角表示我们往左和往右看的程度。滚转角代表我们如何<strong>翻滚</strong>摄像机，通常在太空飞船的摄像机中使用。每个欧拉角都有一个值来表示，把三个角结合起来我们就能够计算3D空间中任何的旋转向量了。</p>
<p>对于我们的摄像机系统来说，我们只关心俯仰角和偏航角，所以我们不会讨论滚转角。给定一个俯仰角和偏航角，我们可以把它们转换为一个代表新的方向向量的3D向量。俯仰角和偏航角转换为方向向量的处理需要一些三角学知识，我们先从最基本的情况开始：</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/camera_triangle.png" alt="camera_triangle"></p>
<p>如果我们把斜边边长定义为1，我们就能知道邻边的长度是$$\cos \ \color{red}x/\color{purple}h = \cos \ \color{red}x/\color{purple}1 = \cos\ \color{red}x$$，它的对边是$$\sin \ \color{green}y/\color{purple}h = \sin \ \color{green}y/\color{purple}1 = \sin\ \color{green}y。$$这样我们获得了能够得到x和y方向长度的通用公式，它们取决于所给的角度。我们使用它来计算方向向量的分量：</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/camera_pitch.png" alt="camera_pitch"></p>
<p>这个三角形看起来和前面的三角形很像，所以如果我们想象自己在xz平面上，看向y轴，我们可以基于第一个三角形计算来计算它的长度/y方向的强度(Strength)（我们往上或往下看多少）。从图中我们可以看到对于一个给定俯仰角的y值等于sin θsin⁡ �：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">direction.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch)); <span class="comment">// 注意我们先把角度转为弧度</span></span><br></pre></td></tr></table></figure>

<p>这里我们只更新了y值，仔细观察x和z分量也被影响了。从三角形中我们可以看到它们的值等于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">direction.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">direction.z = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br></pre></td></tr></table></figure>

<p>看看我们是否能够为偏航角找到需要的分量：</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/camera_yaw.png" alt="camera_yaw"></p>
<p>就像俯仰角的三角形一样，我们可以看到x分量取决于<code>cos(yaw)</code>的值，z值同样取决于偏航角的正弦值。把这个加到前面的值中，会得到基于俯仰角和偏航角的方向向量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">direction.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw)); <span class="comment">// 译注：direction代表摄像机的前轴(Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的</span></span><br><span class="line">direction.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">direction.z = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw));</span><br></pre></td></tr></table></figure>

<p>这样我们就有了一个可以把俯仰角和偏航角转化为用来自由旋转视角的摄像机的3维方向向量了。你可能会奇怪：我们怎么得到俯仰角和偏航角？</p>
<h5 id="鼠标输入"><a href="#鼠标输入" class="headerlink" title="鼠标输入"></a>鼠标输入</h5><p>偏航角和俯仰角是通过鼠标（或手柄）移动获得的，水平的移动影响偏航角，竖直的移动影响俯仰角。它的原理就是，储存上一帧鼠标的位置，在当前帧中我们当前计算鼠标位置与上一帧的位置相差多少。如果水平/竖直差别越大那么俯仰角或偏航角就改变越大，也就是摄像机需要移动更多的距离。</p>
<p>首先我们要告诉GLFW，它应该隐藏光标，并捕捉(Capture)它。捕捉光标表示的是，如果焦点在你的程序上（译注：即表示你正在操作这个程序，Windows中拥有焦点的程序标题栏通常是有颜色的那个，而失去焦点的程序标题栏则是灰色的），光标应该停留在窗口中（除非程序失去焦点或者退出）。我们可以用一个简单地配置调用来完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwSetInputMode</span>(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br></pre></td></tr></table></figure>

<p>在调用这个函数之后，无论我们怎么去移动鼠标，光标都不会显示了，它也不会离开窗口。对于FPS摄像机系统来说非常完美。</p>
<p>为了计算俯仰角和偏航角，我们需要让GLFW监听鼠标移动事件。（和键盘输入相似）我们会用一个回调函数来完成，函数的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xpos, <span class="type">double</span> ypos)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这里的xpos和ypos代表当前鼠标的位置。当我们用GLFW注册了回调函数之后，鼠标一移动mouse_callback函数就会被调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwSetCursorPosCallback</span>(window, mouse_callback);</span><br></pre></td></tr></table></figure>

<p>在处理FPS风格摄像机的鼠标输入的时候，我们必须在最终获取方向向量之前做下面这几步：</p>
<ol>
<li>计算鼠标距上一帧的偏移量。</li>
<li>把偏移量添加到摄像机的俯仰角和偏航角中。</li>
<li>对偏航角和俯仰角进行最大和最小值的限制。</li>
<li>计算方向向量。</li>
</ol>
<p>第一步是计算鼠标自上一帧的偏移量。我们必须先在程序中储存上一帧的鼠标位置，我们把它的初始值设置为屏幕的中心（屏幕的尺寸是800x600）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> lastX = <span class="number">400</span>, lastY = <span class="number">300</span>;</span><br></pre></td></tr></table></figure>

<p>然后在鼠标的回调函数中我们计算当前帧和上一帧鼠标位置的偏移量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> xoffset = xpos - lastX;</span><br><span class="line"><span class="type">float</span> yoffset = lastY - ypos; <span class="comment">// 注意这里是相反的，因为y坐标是从底部往顶部依次增大的</span></span><br><span class="line">lastX = xpos;</span><br><span class="line">lastY = ypos;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> sensitivity = <span class="number">0.05f</span>;</span><br><span class="line">xoffset *= sensitivity;</span><br><span class="line">yoffset *= sensitivity;</span><br></pre></td></tr></table></figure>

<p>注意我们把偏移量乘以了sensitivity（灵敏度）值。如果我们忽略这个值，鼠标移动就会太大了；你可以自己实验一下，找到适合自己的灵敏度值。</p>
<p>接下来我们把偏移量加到全局变量pitch和yaw上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yaw   += xoffset;</span><br><span class="line">pitch += yoffset;</span><br></pre></td></tr></table></figure>

<p>第三步，我们需要给摄像机添加一些限制，这样摄像机就不会发生奇怪的移动了（这样也会避免一些奇怪的问题）。对于俯仰角，要让用户不能看向高于89度的地方（在90度时视角会发生逆转，所以我们把89度作为极限），同样也不允许小于-89度。这样能够保证用户只能看到天空或脚下，但是不能超越这个限制。我们可以在值超过限制的时候将其改为极限值来实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">  pitch =  <span class="number">89.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">  pitch = <span class="number">-89.0f</span>;</span><br></pre></td></tr></table></figure>

<p>注意我们没有给偏航角设置限制，这是因为我们不希望限制用户的水平旋转。当然，给偏航角设置限制也很容易，如果你愿意可以自己实现。</p>
<p>第四也是最后一步，就是通过俯仰角和偏航角来计算以得到真正的方向向量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 front;</span><br><span class="line">front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw));</span><br><span class="line">front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">front.z = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw));</span><br><span class="line">cameraFront = glm::<span class="built_in">normalize</span>(front);</span><br></pre></td></tr></table></figure>

<p>计算出来的方向向量就会包含根据鼠标移动计算出来的所有旋转了。由于cameraFront向量已经包含在GLM的lookAt函数中，我们这就没什么问题了。</p>
<p>如果你现在运行代码，你会发现在窗口第一次获取焦点的时候摄像机会突然跳一下。这个问题产生的原因是，在你的鼠标移动进窗口的那一刻，鼠标回调函数就会被调用，这时候的xpos和ypos会等于鼠标刚刚进入屏幕的那个位置。这通常是一个距离屏幕中心很远的地方，因而产生一个很大的偏移量，所以就会跳了。我们可以简单的使用一个<code>bool</code>变量检验我们是否是第一次获取鼠标输入，如果是，那么我们先把鼠标的初始位置更新为xpos和ypos值，这样就能解决这个问题；接下来的鼠标移动就会使用刚进入的鼠标位置坐标来计算偏移量了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(firstMouse) <span class="comment">// 这个bool变量初始时是设定为true的</span></span><br><span class="line">&#123;</span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line">    firstMouse = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的代码应该是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xpos, <span class="type">double</span> ypos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(firstMouse)</span><br><span class="line">    &#123;</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">        firstMouse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> xoffset = xpos - lastX;</span><br><span class="line">    <span class="type">float</span> yoffset = lastY - ypos; </span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> sensitivity = <span class="number">0.05</span>;</span><br><span class="line">    xoffset *= sensitivity;</span><br><span class="line">    yoffset *= sensitivity;</span><br><span class="line"></span><br><span class="line">    yaw   += xoffset;</span><br><span class="line">    pitch += yoffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">        pitch = <span class="number">89.0f</span>;</span><br><span class="line">    <span class="keyword">if</span>(pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">        pitch = <span class="number">-89.0f</span>;</span><br><span class="line"></span><br><span class="line">    glm::vec3 front;</span><br><span class="line">    front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    front.z = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    cameraFront = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就可以自由地在3D场景中移动了！</p>
<h5 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h5><p>作为我们摄像机系统的一个附加内容，我们还会来实现一个缩放(Zoom)接口。在之前的教程中我们说<strong>视野</strong>(Field of View)或<strong>fov</strong>定义了我们可以看到场景中多大的范围。当视野变小时，场景投影出来的空间就会减小，产生放大(Zoom In)了的感觉。我们会使用鼠标的滚轮来放大。与鼠标移动、键盘输入一样，我们需要一个鼠标滚轮的回调函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xoffset, <span class="type">double</span> yoffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(fov &gt;= <span class="number">1.0f</span> &amp;&amp; fov &lt;= <span class="number">45.0f</span>)</span><br><span class="line">    fov -= yoffset;</span><br><span class="line">  <span class="keyword">if</span>(fov &lt;= <span class="number">1.0f</span>)</span><br><span class="line">    fov = <span class="number">1.0f</span>;</span><br><span class="line">  <span class="keyword">if</span>(fov &gt;= <span class="number">45.0f</span>)</span><br><span class="line">    fov = <span class="number">45.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当滚动鼠标滚轮的时候，yoffset值代表我们竖直滚动的大小。当scroll_callback函数被调用后，我们改变全局变量fov变量的内容。因为<code>45.0f</code>是默认的视野值，我们将会把缩放级别(Zoom Level)限制在<code>1.0f</code>到<code>45.0f</code>。</p>
<p>我们现在在每一帧都必须把透视投影矩阵上传到GPU，但现在使用fov变量作为它的视野：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(fov), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>

<p>最后不要忘记注册鼠标滚轮的回调函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwSetScrollCallback</span>(window, scroll_callback);</span><br></pre></td></tr></table></figure>

<p>现在，我们就实现了一个简单的摄像机系统了，它能够让我们在3D环境中自由移动。</p>
<p><img src="/2023/01/18/OpenGl%E5%AD%A6%E4%B9%A0/camera.gif" alt="camera"></p>
<h4 id="摄像机类"><a href="#摄像机类" class="headerlink" title="摄像机类"></a>摄像机类</h4><p>封装制作一个摄像机类</p>
<h3 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h3><ul>
<li>看看你是否能够修改摄像机类，使得其能够变成一个<strong>真正的</strong>FPS摄像机（也就是说不能够随意飞行）；你只能够呆在xz平面上：<a target="_blank" rel="noopener" href="https://learnopengl.com/code_viewer.php?code=getting-started/camera-exercise1">参考解答</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessKeyboard</span><span class="params">(Camera_Movement direction, <span class="type">float</span> deltaTime)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">float</span> velocity = MovementSpeed * deltaTime;</span><br><span class="line">        <span class="keyword">if</span> (direction == FORWARD)</span><br><span class="line">            Position += Front * velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == BACKWARD)</span><br><span class="line">            Position -= Front * velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == LEFT)</span><br><span class="line">            Position -= Right * velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == RIGHT)</span><br><span class="line">            Position += Right * velocity;</span><br><span class="line">        Position.y = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>试着创建你自己的LookAt函数，其中你需要手动创建一个我们在一开始讨论的观察矩阵。用你的函数实现来替换GLM的LookAt函数，看看它是否还能一样地工作：<a target="_blank" rel="noopener" href="https://learnopengl.com/code_viewer.php?code=getting-started/camera-exercise2">参考解答</a></li>
</ul>
<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><h4 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h4><ul>
<li><strong>OpenGL</strong>： 一个定义了函数布局和输出的图形API的正式规范。</li>
<li><strong>GLAD</strong>： 一个拓展加载库，用来为我们加载并设定所有OpenGL函数指针，从而让我们能够使用所有（现代）OpenGL函数。</li>
<li>**视口(Viewport)**： 我们需要渲染的窗口。</li>
<li>**图形管线(Graphics Pipeline)**： 一个顶点在呈现为像素之前经过的全部过程。</li>
<li>**着色器(Shader)**： 一个运行在显卡上的小型程序。很多阶段的图形管道都可以使用自定义的着色器来代替原有的功能。</li>
<li>**标准化设备坐标(Normalized Device Coordinates, NDC)**： 顶点在通过在剪裁坐标系中剪裁与透视除法后最终呈现在的坐标系。所有位置在NDC下-1.0到1.0的顶点将不会被丢弃并且可见。</li>
<li>**顶点缓冲对象(Vertex Buffer Object)**： 一个调用显存并存储所有顶点数据供显卡使用的缓冲对象。</li>
<li>**顶点数组对象(Vertex Array Object)**： 存储缓冲区和顶点属性状态。</li>
<li>**索引缓冲对象(Element Buffer Object)**： 一个存储索引供索引化绘制使用的缓冲对象。</li>
<li><strong>Uniform</strong>： 一个特殊类型的GLSL变量。它是全局的（在一个着色器程序中每一个着色器都能够访问uniform变量），并且只需要被设定一次。</li>
<li>**纹理(Texture)**： 一种包裹着物体的特殊类型图像，给物体精细的视觉效果。</li>
<li>**纹理缠绕(Texture Wrapping)**： 定义了一种当纹理顶点超出范围(0, 1)时指定OpenGL如何采样纹理的模式。</li>
<li>**纹理过滤(Texture Filtering)**： 定义了一种当有多种纹素选择时指定OpenGL如何采样纹理的模式。这通常在纹理被放大情况下发生。</li>
<li>**多级渐远纹理(Mipmaps)**： 被存储的材质的一些缩小版本，根据距观察者的距离会使用材质的合适大小。</li>
<li><strong>stb_image.h</strong>： 图像加载库。</li>
<li>**纹理单元(Texture Units)**： 通过绑定纹理到不同纹理单元从而允许多个纹理在同一对象上渲染。</li>
<li>**向量(Vector)**： 一个定义了在空间中方向和/或位置的数学实体。</li>
<li>**矩阵(Matrix)**： 一个矩形阵列的数学表达式。</li>
<li><strong>GLM</strong>： 一个为OpenGL打造的数学库。</li>
<li>**局部空间(Local Space)**： 一个物体的初始空间。所有的坐标都是相对于物体的原点的。</li>
<li>**世界空间(World Space)**： 所有的坐标都相对于全局原点。</li>
<li>**观察空间(View Space)**： 所有的坐标都是从摄像机的视角观察的。</li>
<li>**裁剪空间(Clip Space)**： 所有的坐标都是从摄像机视角观察的，但是该空间应用了投影。这个空间应该是一个顶点坐标最终的空间，作为顶点着色器的输出。OpenGL负责处理剩下的事情（裁剪/透视除法）。</li>
<li>**屏幕空间(Screen Space)**： 所有的坐标都由屏幕视角来观察。坐标的范围是从0到屏幕的宽/高。</li>
<li><strong>LookAt矩阵</strong>： 一种特殊类型的观察矩阵，它创建了一个坐标系，其中所有坐标都根据从一个位置正在观察目标的用户旋转或者平移。</li>
<li>**欧拉角(Euler Angles)**： 被定义为偏航角(Yaw)，俯仰角(Pitch)，和滚转角(Roll)从而允许我们通</li>
</ul>

    </div>

    
    
    

	<div>
	  
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

	  
	</div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag"># 图形学</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/03/Lua%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/" rel="prev" title="Lua基础语法学习">
      <i class="fa fa-chevron-left"></i> Lua基础语法学习
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/08/11/%E6%89%93%E5%8D%A1%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E5%A4%A9/" rel="next" title="打卡记录第一周">
      打卡记录第一周 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenGL-GLFW-GLAD"><span class="nav-number">1.</span> <span class="nav-text">OpenGL-GLFW-GLAD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VAO%E3%80%81VBO"><span class="nav-number">2.</span> <span class="nav-text">VAO、VBO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">添加着色器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%9D%80%E8%89%B2%E5%99%A8%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91"><span class="nav-number">3.1.</span> <span class="nav-text">对着色器进行编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E7%BC%93%E5%86%B2%E5%AF%B9%E8%B1%A1EBO"><span class="nav-number">3.2.</span> <span class="nav-text">元素缓冲对象EBO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%8F%A3"><span class="nav-number">3.3.</span> <span class="nav-text">视口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0"><span class="nav-number">3.4.</span> <span class="nav-text">练习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8Shader"><span class="nav-number">4.</span> <span class="nav-text">着色器Shader</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Uniform"><span class="nav-number">4.2.</span> <span class="nav-text">Uniform:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9D%80%E8%89%B2%E5%99%A8%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text">编写自己的着色器类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E7%BB%83%E4%B9%A0"><span class="nav-number">5.1.</span> <span class="nav-text">着色器练习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%B9%E7%90%86"><span class="nav-number">6.</span> <span class="nav-text">纹理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87"><span class="nav-number">6.1.</span> <span class="nav-text">纹理坐标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%B9%E7%90%86%E7%8E%AF%E7%BB%95%E6%96%B9%E5%BC%8F-Texture-Wrapping"><span class="nav-number">6.2.</span> <span class="nav-text">纹理环绕方式(Texture Wrapping)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%B9%E7%90%86%E8%BF%87%E6%BB%A4-Texture-Filtering"><span class="nav-number">6.3.</span> <span class="nav-text">纹理过滤(Texture Filtering)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86"><span class="nav-number">6.4.</span> <span class="nav-text">多级渐远纹理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%9B%E5%BB%BA%E7%BA%B9%E7%90%86"><span class="nav-number">6.5.</span> <span class="nav-text">加载与创建纹理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%B9%E7%90%86%E5%8D%95%E5%85%83"><span class="nav-number">6.6.</span> <span class="nav-text">纹理单元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0-1"><span class="nav-number">6.7.</span> <span class="nav-text">练习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E6%8D%A2"><span class="nav-number">7.</span> <span class="nav-text">变换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E7%82%B9%E4%B9%98%E5%92%8C%E5%8F%89%E4%B9%98"><span class="nav-number">7.1.</span> <span class="nav-text">向量的点乘和叉乘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5"><span class="nav-number">7.2.</span> <span class="nav-text">矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5"><span class="nav-number">7.2.1.</span> <span class="nav-text">单位矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%A9%E6%94%BE%E7%9F%A9%E9%98%B5"><span class="nav-number">7.2.2.</span> <span class="nav-text">缩放矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E7%A7%BB%E7%9F%A9%E9%98%B5"><span class="nav-number">7.2.3.</span> <span class="nav-text">位移矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5"><span class="nav-number">7.2.4.</span> <span class="nav-text">旋转矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E7%BB%84%E5%90%88"><span class="nav-number">7.2.5.</span> <span class="nav-text">矩阵的组合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5"><span class="nav-number">7.3.</span> <span class="nav-text">实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0-2"><span class="nav-number">7.4.</span> <span class="nav-text">练习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F"><span class="nav-number">8.</span> <span class="nav-text">坐标系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">8.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E7%A9%BA%E9%97%B4"><span class="nav-number">8.2.</span> <span class="nav-text">局部空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%96%E7%95%8C%E7%A9%BA%E9%97%B4"><span class="nav-number">8.3.</span> <span class="nav-text">世界空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E7%A9%BA%E9%97%B4"><span class="nav-number">8.4.</span> <span class="nav-text">观察空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4"><span class="nav-number">8.5.</span> <span class="nav-text">裁剪空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88"><span class="nav-number">8.6.</span> <span class="nav-text">组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E5%85%A53D"><span class="nav-number">8.7.</span> <span class="nav-text">进入3D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Z%E7%BC%93%E5%86%B2"><span class="nav-number">8.8.</span> <span class="nav-text">Z缓冲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0-3"><span class="nav-number">8.9.</span> <span class="nav-text">练习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%91%84%E5%83%8F%E6%9C%BA"><span class="nav-number">9.</span> <span class="nav-text">摄像机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%91%84%E5%83%8F%E6%9C%BA-%E8%A7%82%E5%AF%9F%E7%A9%BA%E9%97%B4"><span class="nav-number">9.1.</span> <span class="nav-text">摄像机&#x2F;观察空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%91%84%E5%83%8F%E6%9C%BA%E4%BD%8D%E7%BD%AE"><span class="nav-number">9.1.1.</span> <span class="nav-text">1. 摄像机位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%91%84%E5%83%8F%E6%9C%BA%E6%96%B9%E5%90%91"><span class="nav-number">9.1.2.</span> <span class="nav-text">2. 摄像机方向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%8F%B3%E8%BD%B4"><span class="nav-number">9.1.3.</span> <span class="nav-text">3. 右轴</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%B8%8A%E8%BD%B4"><span class="nav-number">9.1.4.</span> <span class="nav-text">4. 上轴</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Look-At"><span class="nav-number">9.2.</span> <span class="nav-text">Look At</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E7%94%B1%E7%A7%BB%E5%8A%A8"><span class="nav-number">9.3.</span> <span class="nav-text">自由移动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E9%80%9F%E5%BA%A6"><span class="nav-number">9.3.1.</span> <span class="nav-text">移动速度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%86%E8%A7%92%E7%A7%BB%E5%8A%A8"><span class="nav-number">9.3.2.</span> <span class="nav-text">视角移动</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E8%A7%92"><span class="nav-number">9.3.2.1.</span> <span class="nav-text">欧拉角</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%BC%A0%E6%A0%87%E8%BE%93%E5%85%A5"><span class="nav-number">9.3.2.2.</span> <span class="nav-text">鼠标输入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%A9%E6%94%BE"><span class="nav-number">9.3.2.3.</span> <span class="nav-text">缩放</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%91%84%E5%83%8F%E6%9C%BA%E7%B1%BB"><span class="nav-number">9.3.3.</span> <span class="nav-text">摄像机类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0-4"><span class="nav-number">9.4.</span> <span class="nav-text">练习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E4%B9%A0"><span class="nav-number">10.</span> <span class="nav-text">复习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%8D%E6%B1%87%E8%A1%A8"><span class="nav-number">10.0.1.</span> <span class="nav-text">词汇表</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="DruidYun"
      src="/images/DruidYun.jpg">
  <p class="site-author-name" itemprop="name">DruidYun</p>
  <div class="site-description" itemprop="description">如果你想做出让人享受的东西，那就享受做它的过程</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/druidyun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;druidyun" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:druidyun@outlook.com" title="E-Mail → mailto:druidyun@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fab fa-angellist"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DruidYun</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">73k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:07</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
